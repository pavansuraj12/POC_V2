<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hen Detection â€“ CCTV Mode</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
  margin: 0;
  background: black;
  color: white;
  font-family: Arial, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
}

#container {
  position: relative;
  width: 90vw;
  max-width: 720px;
  aspect-ratio: 4 / 3;
  background: black;
}

video, canvas {
  position: absolute;
  width: 100%;
  height: 100%;
}

canvas { pointer-events: none; }

#fps {
  position: absolute;
  top: 6px;
  left: 6px;
  color: #0f0;
  font-family: monospace;
  background: rgba(0,0,0,0.6);
  padding: 4px 6px;
}

button {
  margin: 10px;
  padding: 8px 14px;
}
</style>
</head>

<body>

<button onclick="start()">â–¶ Start Camera</button>

<div id="container">
  <video id="video" autoplay muted playsinline></video>
  <canvas id="canvas"></canvas>
  <div id="fps">FPS: --</div>
</div>

<script>
/* ================= CONFIG ================= */
const WS_URL = "wss://unraided-camren-streamingly.ngrok-free.dev";

// ðŸ”¥ IMPORTANT: detection FPS (lower = smoother on ngrok)
const DETECTION_FPS = 5;          // try 3â€“6 on ngrok
const MODEL_INPUT_SIZE = 640;     // reduce payload

/* ================= GLOBALS ================= */
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const fpsLabel = document.getElementById("fps");

let socket;
let detections = [];
let lastRenderTime = performance.now();
let lastDetectTime = 0;
let videoW = 0, videoH = 0;
let started = false;

/* ================= START ================= */
async function start() {
  if (started) return;
  started = true;
  await startCamera();
  startWebSocket();
}

/* ================= CAMERA ================= */
async function startCamera() {
  const stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: { ideal: "environment" } },
    audio: false
  });

  video.srcObject = stream;

  video.onloadedmetadata = () => {
    videoW = video.videoWidth;
    videoH = video.videoHeight;
    canvas.width = videoW;
    canvas.height = videoH;
    requestAnimationFrame(renderLoop);
  };
}

/* ================= WEBSOCKET ================= */
function startWebSocket() {
  socket = new WebSocket(WS_URL);
  socket.onmessage = e => {
    detections = JSON.parse(e.data).detections || [];
  };
}

/* ================= SEND FRAME (RATE LIMITED) ================= */
function sendFrame(now) {
  if (!socket || socket.readyState !== 1) return;
  if (now - lastDetectTime < 1000 / DETECTION_FPS) return;

  lastDetectTime = now;

  const tmp = document.createElement("canvas");
  tmp.width = MODEL_INPUT_SIZE;
  tmp.height = MODEL_INPUT_SIZE;

  tmp.getContext("2d").drawImage(video, 0, 0, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE);

  socket.send(JSON.stringify({
    frame: tmp.toDataURL("image/jpeg", 0.6).split(",")[1]
  }));
}

/* ================= RENDER LOOP ================= */
function renderLoop(now) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const sx = canvas.width / MODEL_INPUT_SIZE;
  const sy = canvas.height / MODEL_INPUT_SIZE;

  detections.forEach(d => {
    ctx.strokeStyle = "lime";
    ctx.lineWidth = 2;
    ctx.strokeRect(
      d.x1 * sx,
      d.y1 * sy,
      (d.x2 - d.x1) * sx,
      (d.y2 - d.y1) * sy
    );
  });

  const fps = Math.round(1000 / (now - lastRenderTime));
  lastRenderTime = now;
  fpsLabel.innerText = `FPS: ${fps}`;

  sendFrame(now);
  requestAnimationFrame(renderLoop);
}
</script>
</body>
</html>
